% This code is used for checking the trajectories 
% generated by monalisa vs. pulseq
% Yiwei Jia April 17
% --------------------------------------------------------------------
%%
clc;clear;
addpath(genpath('/Users/cag/Documents/forclone/pulseq_v15/pulseq'));
%% original
seqPath = strcat('/Users/cag/Documents/forclone/pulseq4mreye/mreye2p0_0424/', ...
       'sub3_mauro_gre_pre_oriTraj.seq');


nSeg=22;
nShot=419;
N = 160;
k_trj = extract_traj_pulseq(seqPath, nSeg, nShot, N);
%%
traj_design = 0;    % Trajectory design: 0 = original, 1 = pole-to-pole, 2 = continuous, 3 = unishuffle
plot_flag = 1;

nSeg=22;
nShot=419;
N = 160;

Traj3D = calc_traj_monalisa(traj_design, nSeg, nShot, N, plot_flag);
%%
R =   abs(min(k_trj(:)));
t_monalisa = permute(Traj3D, [4,1,2,3]); 
t_pulseq = k_trj/R*0.5;
tol = 1e-4;
isclose = check_traj_diff(t_monalisa, t_pulseq, tol);

%% unishuffle
seqPath = strcat('/Users/cag/Documents/forclone/pulseq4mreye/mreye2p0/', ...
        'sub4_gre_pre_oriTraj.seq');
%%
function k_trj = extract_traj_pulseq(seqPath, nSeg, nShot, N)
    grad_mode = 'Fast';
    switch grad_mode
        case 'Fast'
            max_grad = 26;      % Max gradient strength [mT/m]
            max_slew = 120;  % Maximum slew rate [mT/m/ms] orginial 120
        case 'Normal'
            max_grad = 22;      % Max gradient strength [mT/m]
            max_slew = 120;     % Maximum slew rate [mT/m/ms]
        case 'Whisper'
            max_grad = 12;      % Max gradient strength [mT/m]
            max_slew = 40;      % Maximum slew rate [mT/m/ms]
        case 'Performance'
            max_grad = 40;      % Max gradient strength [mT/m]
            max_slew = 160;  % Maximum slew rate [mT/m/ms]
    end
    
    
    
    sys = mr.opts('MaxGrad',max_grad,'GradUnit','mT/m',...
        'MaxSlew',max_slew,'SlewUnit','T/m/s',...
        'rfRingdownTime', 20e-6, 'rfDeadTime', 100e-6, ...
        'adcDeadTime', 20e-6, 'B0', 2.89);
    
    seq=mr.Sequence(sys);
    disp(['Reading seq file: ', seqPath]);
    seq.read(seqPath);
    
    kspace_traj = seq.calculateKspacePP;
    
    k_trj = reshape(kspace_traj, [3, N, nSeg, nShot]);

end


function Traj3D = calc_traj_monalisa(traj_design, nSeg, nShot, N, plot_flag)
    flagSelfNav = 1;
    
    switch traj_design
        case 0
            disp('Original trajectory')
            [polarAngle, azimuthalAngle, vx, vy, vz] = phyllotaxis3D_original(nShot, nSeg, flagSelfNav);
        case 1
            [polarAngle, azimuthalAngle, vx, vy, vz] = phyllotaxis3D_poletopole(nShot, nSeg, flagSelfNav);
        case 2
            [polarAngle, azimuthalAngle, vx, vy, vz] = phyllotaxis3D_continuous(nShot, nSeg, flagSelfNav);
        case 3
            disp('Unishuffled trajectory')
            [polarAngle, azimuthalAngle, vx, vy, vz] = phyllotaxis3D_uniform_shuffled(nShot, nSeg, flagSelfNav);
    end

    if plot_flag
        % Plot the trajectory
        t = figure('Color', 'White', 'Position', [100, 100, 900, 400]);
        
        % Plot the 3D trajectory for 5 interleaves
        subplot(1, 2, 1);
        for i = 1:5
            plot3(vx(1, (i-1)*nSeg+1:i*nSeg), vy(1, (i-1)*nSeg+1:i*nSeg), vz(1, (i-1)*nSeg+1:i*nSeg), ...
                '.-', 'Markersize', 10, 'LineWidth', 2); grid on;
            hold on;
        end
        xlabel('x'); ylabel('y'); zlabel('z');
        axis([-1 1 -1 1 -1 1])
        title('Trajectory for 5 interleaves');
        
        % Plot polar and azimuthal angles for the first interleave
        subplot(1, 2, 2);
        i = 1;
        plot(polarAngle(1, (i-1)*nSeg+1:i*nSeg), '.-', 'Markersize', 10, 'LineWidth', 2); hold on;
        plot(azimuthalAngle(1, (i-1)*nSeg+1:i*nSeg), '.-', 'Markersize', 10, 'LineWidth', 2); grid on;
        legend('Polar angle', 'Azimuthal angle');
        xlabel('#Segments'); ylabel('Angle [rad]');
        title('Azimuthal and polar angle for one interleave');
        % exportgraphics(t,[path,'trajectory_continuous.png'],'Resolution',400)
    end

    % Define readout
    % r = (-0.5 : 1/(N-1) : 0.5);
    % Monalisa way
    r = (-0.5 : 1/N : 0.5-(1/N));
    
    % Replicate angles for readout
    azimuthal = repmat(azimuthalAngle, [N, 1]);
    polar     = repmat(pi/2 - polarAngle, [N, 1]); % is defined like this in IDEA
    R         = repmat(r', [1, nShot * nSeg]);
    
    % Convert spherical coordinates to Cartesian coordinates
    [kx, ky, kz] = sph2cart(azimuthal, polar, R);
    
    % Reshape the coordinates
    kx = reshape(kx, [N, nSeg, nShot]);
    ky = reshape(ky, [N, nSeg, nShot]);
    kz = reshape(kz, [N, nSeg, nShot]);
    
    % Trajectory used for reconstruction
    Traj3D   = cat(4, kx, ky, kz);


end


function isclose = check_traj_diff(t_monalisa, t_pulseq, tol) 
    
    fprintf('Setting tolerence: %f \n', tol);

    % Compute the difference
    diff = abs(squeeze(t_monalisa(:,:,:)) - squeeze(t_pulseq(:,:,:)));
    % Check if all differences are below tolerance
    if all(diff(:) < tol)
        disp('All elements are close within the specified tolerance.');
        isclose=1;
    else
        isclose=0;
        disp('Some elements differ beyond the tolerance.');    
        % Optionally, show where and how much
        [i, j] = find(diff >= tol);
        for idx = 1:length(i)
            fprintf('Mismatch at (%d, %d):  -t = %g, ref = %g, diff = %g\n', ...
                i(idx), j(idx), ...
                t_monalisa(1,i(idx),j(idx)), ...
                t_pulseq(1,i(idx),j(idx)), ...
                diff(i(idx),j(idx)));
        end
        
    end

end